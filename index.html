<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - GLTFloader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        * {
            padding: 0px;
            margin: 0px;
        }

        html,
        body {
            overflow: hidden;
        }

        .menu-button {
            position: fixed;
            left: 32px;
            top: 60px;
            width: 32px;
            height: 32px;
            border-radius: 2px;
            cursor: pointer;
            background-color: #fff;
            box-shadow: 5px 2px 5px #ccc;
        }

        .menu-container {
            position: fixed;
            left: 32px;
            top: 100px;
            z-index: 9999999;
            width: 160px;
            background-color: white;
            max-height: 50vh;
            overflow-y: scroll;
        }

        .menu-children-container {
            position: fixed;
            left: 180px;
            top: 100px;
            z-index: 9999999;
            width: 120px;
            background-color: white;
            max-height: 50vh;
            display: none;
            overflow-y: scroll;
        }

        .menu-children-container.show {
            display: block;
        }

        .menu-list {
            display: flex;
            flex-direction: column;
        }

        .menu-list>.menu-item {
            width: 100%;
            height: 33px;
            line-height: 33px;
            text-align: center;
            box-sizing: border-box;
            background-color: #fff;
            border: 1px solid #ddd;
            cursor: pointer;
            position: relative;
        }

        .menu-list>.menu-item.show-arrow {
            padding-right: 12px;
        }

        .menu-list>.menu-item.show-arrow::after {
            content: '▶';
            position: absolute;
            right: 12px;
            color: #ddd;
            font-size: 8px;
        }

        .menu-list>.menu-item.checked,
        .menu-list>.menu-item:hover {
            background-color: #ccc;
        }

        div.search-box {
            display: flex;
            position: fixed;
            left: 32px;
            top: 20px;
            font-size: 20px;
            color: #e7ae9b;
        }

        div.search-box input {
            outline: none;
            border: 1px solid #e7ae9b;
            margin-left: 12px;
            padding-left: 8px;
            outline-style: none;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div class="acupoints-name">文本</div>
    <div class="menu-button">
        <img src="./imgs/menu.png">
    </div>
    <div class="menu-container">
        <div class="menu-list"></div>
    </div>
    <div class="menu-children-container">
        <div class="menu-list"></div>
    </div>
    <div class="search-box">
        <label for="input-acupoints">穴位: </label>
        <input list="acupoints-data-list" id="input-acupoints" name="input-acupoints" placeholder="请输入穴位">
    </div>
    <datalist id="acupoints-data-list"></datalist>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/jsm/"
            }
        }
    </script>
    <script type="module">
        import { man } from './models/man.js'
        import { TWEEN } from 'https://unpkg.com/three@0.139.0/examples/jsm/libs/tween.module.min.js';
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

        import {
            CSS2DRenderer,
            CSS2DObject,
        } from "three/addons/renderers/CSS2DRenderer.js";

        const MyUtils = {
            textureToCanvas: function (texture) {
                const canvas = document.createElement('canvas');
                canvas.width = texture.image.width;
                canvas.height = texture.image.height;
                const context = canvas.getContext('2d');
                context.drawImage(texture.image, 0, 0);
                return canvas;
            }
        };

        var index = 0;
        var list = [];
        var idList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        var preLoadMeshList = [];

        const container = document.getElementById('container');
        let renderer, scene, camera, canvas, texture, targetObject, angle;
        let mesh;
        let raycaster;
        let line;
        const position = new THREE.Vector3();
        const decals = [];
        let finalPosition;
        let objPosition;

        const intersection = {
            intersects: false,
            point: new THREE.Vector3(),
            normal: new THREE.Vector3()
        };

        const mouse = new THREE.Vector2();
        const intersects = [];
        let mouseHelper;

        const params = {
            minScale: 0.5,
            maxScale: 100,
            rotate: true,
            clear: function () {
                removeDecals();
            }
        };

        init();
        animate();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            renderer.setClearColor(0xcccccc);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 120;
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 50;
            controls.maxDistance = 200;

            scene.add(new THREE.AmbientLight(0x443333));

            const dirLight1 = new THREE.DirectionalLight(0xffddcc, 1);
            dirLight1.position.set(1, 0.75, 0.5);
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0xccccff, 1);
            dirLight2.position.set(-1, 0.75, -0.5);
            scene.add(dirLight2);

            const geometry = new THREE.BufferGeometry();
            geometry.setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);

            line = new THREE.Line(geometry, new THREE.LineBasicMaterial());
            scene.add(line);

            loadLeePerrySmith();

            raycaster = new THREE.Raycaster();

            mouseHelper = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 10), new THREE.MeshNormalMaterial());
            mouseHelper.visible = false;
            scene.add(mouseHelper);
            window.addEventListener('resize', onWindowResize);
            let moved = false;
            controls.addEventListener('change', function () {
                moved = true;
            });

            window.addEventListener('pointerdown', function () {
                moved = false;
            });

            window.addEventListener('pointerup', function (event) {
                if (Object.prototype.toString.call(event.target) == '[object HTMLCanvasElement]') {
                    if (moved === false) {
                        checkIntersection(event.clientX, event.clientY);
                        if (intersection.intersects) {
                            shoot();
                        }
                    }
                }
            });

            window.addEventListener('pointermove', onPointerMove);

            function onPointerMove(event) {
                if (event.isPrimary) {
                    checkIntersection(event.clientX, event.clientY);
                }
            }

            document.addEventListener('click', function (event) {
                checkIntersection(event.clientX, event.clientY, true);
            });

            function checkIntersection(x, y, flag) {
                if (mesh === undefined) return;
                mouse.x = (x / window.innerWidth) * 2 - 1;
                mouse.y = - (y / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                raycaster.intersectObject(mesh, false, intersects);
                if (intersects.length > 0) {
                    if (flag) {
                        // console.dir(intersects[0]);
                    }
                    const p = intersects[0].point;
                    mouseHelper.position.copy(p);
                    intersection.point.copy(p);
                    const n = intersects[0].face.normal.clone();
                    n.transformDirection(mesh.matrixWorld);
                    n.multiplyScalar(10);
                    n.add(intersects[0].point);
                    intersection.normal.copy(intersects[0].face.normal);
                    mouseHelper.lookAt(n);
                    const positions = line.geometry.attributes.position;
                    positions.setXYZ(0, p.x, p.y, p.z);
                    positions.setXYZ(1, n.x, n.y, n.z);
                    positions.needsUpdate = true;
                    intersection.intersects = true;
                    intersects.length = 0;
                } else {
                    intersection.intersects = false;
                }
            }
            // const gui = new GUI();
            // gui.add(params, 'clear');
            // gui.open();

        }
        var loader = new THREE.TextureLoader();
        texture = loader.load("models/ren_maps/RenTi_MediumColor.jpg");

        function loadLeePerrySmith() {
            // // 创建一个 OBJLoader 和 MTLLoader
            var objLoader = new OBJLoader();
            var mtlLoader = new MTLLoader();
            // 使用 MTLLoader 加载 MTL 文件
            mtlLoader.load('models/man.mtl', function (materials) {
                // 将材质应用于 OBJLoader 加载的对象
                materials.preload();
                objLoader.setMaterials(materials);
                // 使用 OBJLoader 加载 OBJ 文件
                objLoader.load('models/man.obj', function (object) {
                    mesh = object.children[0];
                    object.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            canvas = MyUtils.textureToCanvas(texture);
                            child.material.map = texture;
                        }
                    });
                    preRender();
                    // 将对象添加到场景中
                    // scene.add(object);
                    targetObject = object;
                    scene.add(targetObject);
                    targetObject.scale.set(0.5, 0.5, 0.5)
                    // 将模型的中心点设置到canvas坐标系的中心点，保证模型显示是居中的，object就是操作的目标模型
                    let box = new THREE.Box3().setFromObject(object); // 获取模型的包围盒
                    let mdlen = box.max.x - box.min.x; // 模型长度
                    let mdwid = box.max.z - box.min.z; // 模型宽度
                    let mdhei = box.max.y - box.min.y; // 模型高度
                    let x1 = box.min.x + mdlen / 2; // 模型中心点坐标X
                    let y1 = box.min.y + mdhei / 2; // 模型中心点坐标Y
                    let z1 = box.min.z + mdwid / 2; // 模型中心点坐标Z
                    object.position.set(-x1, -y1, -z1); // 将模型进行偏移
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.outputEncoding = THREE.sRGBEncoding;
                    object.position.set(-x1, -y1, -z1); // 将模型进行偏移
                    objPosition = object.position;
                    finalPosition = camera.position;
                });
            });

        }

        function shoot() {
            position.copy(intersection.point);
            // // 创建一个圆球的几何体
            // const radius = 0.2; // 圆球的半径
            // const widthSegments = 12; // 球体宽度上的分段数
            // const heightSegments = 12; // 球体高度上的分段数
            // const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
            // // 创建一个材质
            // const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            // // 创建一个圆球的网格模型
            // const sphere = new THREE.Mesh(geometry, material);
            // sphere.position.set(position.x, position.y, position.z);
            // // 将圆球添加到场景中
            // decals.push(sphere);
            // mesh.attach(sphere)
            // list.push({ id: index++, position: { x: position.x, y: position.y, z: position.z }, x: sphere.matrix.elements[12], y: sphere.matrix.elements[13], z: sphere.matrix.elements[14] })
            // if (list.length == 51) {
            //     console.log(list)
            // }
        }

        function addFont2(cube, model) {
            // Create text geometry
            const fontLoader = new FontLoader();
            fontLoader.load('fonts/Microsoft_JhengHei_Regular.json', function (font) {
                var textGeometry = new THREE.TextGeometry(model.name || '', {
                    font: font,
                    size: 0.2,
                    height: 0.1
                });
                var textMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                var textMesh = new THREE.Mesh(textGeometry, textMaterial);
                // Position the text above the mesh
                textMesh.position.copy(cube.position);
                textMesh.position.y += 1;
                // Add the text mesh to the scene
                scene.add(textMesh);
                // Set camera position
                camera.position.z = 5;
                // Render the scene
                function animate() {
                    requestAnimationFrame(animate);
                    cube.rotation.x += 0.01;
                    cube.rotation.y += 0.01;
                    renderer.render(scene, camera);
                }
                animate();
            });
        }

        function addFont(m, model) {
            console.log(m)
            const fontLoader = new FontLoader();
            fontLoader.load('fonts/FZKai-Z03S_Regular.json', function (font) {
                console.log('font', font)
                var text = model.name;
                var geometry = new TextGeometry(text, {
                    font: font,          // 字体格式
                    size: 1,           // 字体大小
                    height: 0.1,          // 字体深度
                    curveSegments: 11,  // 曲线控制点数
                    bevelEnabled: false, // 斜角
                    bevelThickness: 0.1,  // 斜角的深度
                    bevelSize: 1,       // 斜角的大小
                    bevelSegments: 1    // 斜角段数
                });
                var mat = new THREE.MeshPhongMaterial({
                    color: "red",
                    opacity: 0.8,
                    shininess: 1,
                });
                var mesh1 = new THREE.Mesh(geometry, mat);
                mesh1.needsUpdate = true;
                mesh1.rotation.y = ((model.y * angle) / 2 - (-angle - 1) / 2) / 2;
                mesh1.position.set(model.position.x + model.x / 4, model.position.y, model.position.z - (1 - model.z));
                mesh.attach(mesh1);
                decals.push(mesh1);
            });
        }

        function removeDecals() {
            decals.forEach(function (d) {
                mesh.remove(d);
            });
            decals.length = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }


        // 把所有穴位点全部添加到人体上，并设置成不透明
        function preRender() {
            for (var i = 0; i < preLoadMeshList.length; i++) {
                var model = preLoadMeshList[i];
                // 创建一个圆球的几何体
                const radius = 0.3; // 圆球的半径
                const widthSegments = 15; // 球体宽度上的分段数
                const heightSegments = 15; // 球体高度上的分段数
                const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
                // 创建一个材质
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 });
                // 创建一个圆球的网格模型
                var mesh1 = new THREE.Mesh(geometry, material);
                // Set the transformation matrix
                var matrix = new THREE.Matrix4();
                matrix.makeTranslation(model.x, model.y, model.z);
                mesh1.matrix = matrix;
                mesh1.position.setFromMatrixPosition(matrix);
                mesh1.rotation.setFromRotationMatrix(matrix);
                mesh1.name = `${model.id}`;
                mesh.attach(mesh1);
            }
        }

        document.querySelector('.menu-button').addEventListener('click', function (e) {
            if (document.querySelector('.menu-container > .menu-list').innerHTML) {
                hideMenuContainer();
            } else {
                showMenuContainer();
            }
        })

        function showMenuContainer() {
            const menuList = man.map((e, i) => `<div class="menu-item show-arrow" data-index="${i}">${e.name}</div>`);
            document.querySelector('.menu-container > .menu-list').innerHTML = menuList.join('')
            document.querySelector('.menu-container > .menu-list').addEventListener('mouseover', function (e) {
                const index = e.target.dataset.index;
                if (index >= 0) {
                    const list = man[index].acupoints;
                    const childBox = document.querySelector('.menu-children-container');
                    if (childBox) {
                        childBox.classList.add('show');
                        var childrenBox = list.map((e, i) => `<div class="menu-item" data-id="${e.id}">${e.name}</div>`).join('');
                        childBox.querySelector('.menu-list').innerHTML = childrenBox
                        document.querySelectorAll('.menu-list > .menu-item').forEach(e => e.classList.remove('checked'))
                        e.target.classList.add('checked')
                    }
                }
            })

            document.querySelector('.menu-children-container .menu-list').addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.target.dataset.id) {
                    hideMenuContainer();
                    for (var d of man) {
                        const v = d.acupoints.find(v => v.id == e.target.dataset.id)
                        if (v) {
                            onAcupointsClick(v)
                            return;
                        }
                    }
                }
            }, true)
        }

        function hideMenuContainer() {
            document.querySelector('.menu-children-container').classList.remove('show');
            document.querySelector('.menu-container > .menu-list').innerHTML = ''
            document.querySelector('.menu-children-container > .menu-list').innerHTML = ''
        }

        function setSearchBoxDataList() {
            const ele = document.querySelector('#acupoints-data-list')
            const list = man.map((d) => d.acupoints.map(e => `<option value='${e.name}' data-id='${e.id}'/>`).join('')).join('')
            ele.innerHTML = list


            for (var d of man) {
                for (var d1 of d.acupoints) {
                    preLoadMeshList.push(d1)
                }
            }
        }

        function onAcupointsValueChanged(e) {
            const ele = document.querySelector('#acupoints-data-list')
            const option = ele && ele.querySelector(`option[value=${e.target.value}]`)
            const id = option && option.dataset.id
            if (id) {
                for (var d of man) {
                    const v = d.acupoints.find(v => v.id == id)
                    if (v) {
                        onAcupointsClick(v)
                        return;
                    }
                }
            }

        }

        setSearchBoxDataList();

        document.querySelector('#input-acupoints').addEventListener('change', onAcupointsValueChanged);

        function onAcupointsClick(obj) {
            camera.position.set(finalPosition.x, finalPosition.y, finalPosition.z)
            camera.lookAt(finalPosition);
            setTimeout(() => {
                mesh.children.forEach(e => e.material.opacity = 0);
                removeDecals()
                var cube = mesh.children.find(e => e.name == `${obj.id}`)
                cube.material.opacity = 1;
                addFont(cube, obj);
                angle = Math.atan2(obj.position.z - finalPosition.z, obj.position.x - finalPosition.x);
                console.log(angle)
                camera.position.set(obj.position.x, obj.position.y, obj.position.z)
                camera.lookAt(cube.position);
                // 创建一个模拟的鼠标滚轮事件
                const wheelEvent = new MouseEvent('wheel', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    deltaY: 5
                });
                // 获取需要触发滚轮事件的元素
                const element = document.querySelector('canvas');
                // 触发滚轮事件
                element.dispatchEvent(wheelEvent);
            }, 100);
        }
    </script>
</body>

</html>