<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - GLTFloader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="./css/main.css">
</head>

<body>
    <div class="content">
        <div class="body-container">
            <canvas id="render-box"></canvas>
        </div>
        <div class="body-control">

        </div>
    </div>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        let camera, scene, renderer, controls, geometry, object;
        const decals = [];
        const params = {
            minScale: 10,
            maxScale: 20,
            rotate: true,
            clear: function () {
                removeDecals();
            }
        };
        init();
        animate();

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );


        function init() {
            const renderBox = document.querySelector('#render-box');
            camera = new THREE.PerspectiveCamera(15, renderBox.clientWidth / renderBox.clientHeight, 1.5, 23000);
            camera.position.set(-180, -10, 520);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a0);
            scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
            hemiLight.position.set(0, 100, 0);
            scene.add(hemiLight);

            new MTLLoader().load("models/1.mtl", function (materials) {
                materials.preload();
                new OBJLoader().setMaterials(materials)
                .load("models/1.obj", function (obj) {
                    object = obj;
                    object.scale.set(0.01, 0.01, 0.01);
                    var texture = new THREE.TextureLoader().load("models/ren_maps/RenTi_MediumColor.jpg");
                    console.dir(texture);
                    object.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material.map = texture;
                        }
                    });
                    scene.add(object);
                });
            });
            renderer = new THREE.WebGLRenderer({ canvas: renderBox });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(renderBox.clientWidth, renderBox.clientHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            renderer.outputEncoding = THREE.sRGBEncoding;
            const environment = new RoomEnvironment();
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.background = new THREE.Color(0xffffff);
            scene.environment = pmremGenerator.fromScene(environment).texture;
            camera.aspect = 1.2;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.minDistance = 3;
            controls.maxDistance = 10;
            controls.target.set(0, 1, 0);
            controls.update();
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            // camera.aspect = renderBox.clientWidth / renderBox.clientHeight;
            // camera.updateProjectionMatrix();
            // renderer.setSize(renderBox.clientWidth, renderBox.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // required if damping enabled
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function removeDecals() {
            decals.forEach(function (d) {
                scene.remove(d);
            });
            decals.length = 0;
        }

        function onDocumentMouseDown( e ) {
            e.preventDefault();
            var vectorMouse = new THREE.Vector3( //vector from camera to mouse
                -(window.innerWidth/2-e.clientX)*2/window.innerWidth,
                (window.innerHeight/2-e.clientY)*2/window.innerHeight,
                -1/Math.tan(22.5*Math.PI/180)); //22.5 is half of camera frustum angle 45 degree
            vectorMouse.applyQuaternion(camera.quaternion);
            vectorMouse.normalize();        

            var vectorObject = new THREE.Vector3(); //vector from camera to object
            vectorObject.set(object.x - camera.position.x,
                            object.y - camera.position.y,
                            object.z - camera.position.z);
            vectorObject.normalize();
            if (vectorMouse.angleTo(vectorObject)*180/Math.PI < 1) {
                //mouse's position is near object's position
                console.dir(vectorMouse);

            }
        }
    </script>
</body>

</html>