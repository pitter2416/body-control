<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - GLTFloader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        * {
            cursor: crosshair;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/jsm/"
            }
        }
    </script>
    <script type="module">
        import { TWEEN } from 'https://unpkg.com/three@0.139.0/examples/jsm/libs/tween.module.min.js';
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

        
        const MyUtils = {
            textureToCanvas: function(texture) {
                const canvas = document.createElement('canvas');
                canvas.width = texture.image.width;
                canvas.height = texture.image.height;
                const context = canvas.getContext('2d');
                context.drawImage(texture.image, 0, 0);
                return canvas;
            }
        };
        
        var index = 0;
        var list = [];
        var idList = [1,2,3,4,5,6,7,8,9,10,11]

        var preLoadMeshList = [];

        const container = document.getElementById( 'container' );

        let renderer, scene, camera, stats, canvas, texture, targetObject;
        let mesh;
        let raycaster;
        let line;
        const position = new THREE.Vector3();
        const decals = [];

        const intersection = {
            intersects: false,
            point: new THREE.Vector3(),
            normal: new THREE.Vector3()
        };

        const mouse = new THREE.Vector2();
        const intersects = [];
        let mouseHelper;

        const params = {
            minScale: 0.5,
            maxScale: 100,
            rotate: true,
            clear: function () {
                removeDecals();
            }
        };

        init();
        animate();

        function loadMeshDatas() {
            preLoadMeshList = JSON.parse(`[]`);
        }

        function init() {
            loadMeshDatas();
            renderer = new THREE.WebGLRenderer( { antialias: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            stats = new Stats();
            container.appendChild( stats.dom );

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.z = 120;

            const controls = new OrbitControls( camera, renderer.domElement );
            controls.minDistance = 50;
            controls.maxDistance = 200;

            scene.add( new THREE.AmbientLight( 0x443333 ) );

            const dirLight1 = new THREE.DirectionalLight( 0xffddcc, 1 );
            dirLight1.position.set( 1, 0.75, 0.5 );
            scene.add( dirLight1 );

            const dirLight2 = new THREE.DirectionalLight( 0xccccff, 1 );
            dirLight2.position.set( - 1, 0.75, - 0.5 );
            scene.add( dirLight2 );

            const geometry = new THREE.BufferGeometry();
            geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] );

            line = new THREE.Line( geometry, new THREE.LineBasicMaterial() );
            scene.add( line );

            loadLeePerrySmith();

            raycaster = new THREE.Raycaster();

            mouseHelper = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial() );
            mouseHelper.visible = false;
            scene.add( mouseHelper );
            window.addEventListener( 'resize', onWindowResize );
            let moved = false;
            controls.addEventListener( 'change', function () {
                moved = true;
            });

            window.addEventListener( 'pointerdown', function () {
                moved = false;
            });

            window.addEventListener( 'pointerup', function ( event ) {
                if ( moved === false ) {
                    checkIntersection( event.clientX, event.clientY );
                    if ( intersection.intersects ){
                        shoot();
                    }
                }
            });

            window.addEventListener( 'pointermove', onPointerMove );

            function onPointerMove( event ) {
                if ( event.isPrimary ) {
                    checkIntersection( event.clientX, event.clientY );
                }
            }

            document.addEventListener('click', function(event) {
                checkIntersection( event.clientX, event.clientY, true );
            });

            function checkIntersection( x, y, flag ) {
                if ( mesh === undefined ) return;
                mouse.x = ( x / window.innerWidth ) * 2 - 1;
                mouse.y = - ( y / window.innerHeight ) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );
                raycaster.intersectObject( mesh, false, intersects );
                if ( intersects.length > 0 ) {
                    if(flag) {
                        console.dir(intersects[0]);
                    }
                    const p = intersects[ 0 ].point;
                    mouseHelper.position.copy( p );
                    intersection.point.copy( p );
                    const n = intersects[ 0 ].face.normal.clone();
                    n.transformDirection( mesh.matrixWorld );
                    n.multiplyScalar( 10 );
                    n.add( intersects[ 0 ].point );
                    intersection.normal.copy( intersects[ 0 ].face.normal );
                    mouseHelper.lookAt( n );
                    const positions = line.geometry.attributes.position;
                    positions.setXYZ( 0, p.x, p.y, p.z );
                    positions.setXYZ( 1, n.x, n.y, n.z );
                    positions.needsUpdate = true;
                    intersection.intersects = true;
                    intersects.length = 0;
                } else {
                    intersection.intersects = false;
                }
            }
            const gui = new GUI();
            gui.add( params, 'clear' );
            gui.open();

        }
        var loader = new THREE.TextureLoader();
        texture = loader.load("models/ren_maps/RenTi_MediumColor.jpg");

        function loadLeePerrySmith() {
            // // 创建一个 OBJLoader 和 MTLLoader
            var objLoader = new OBJLoader();
            var mtlLoader = new MTLLoader();
            // 使用 MTLLoader 加载 MTL 文件
            mtlLoader.load('models/man.mtl', function(materials) {
                // 将材质应用于 OBJLoader 加载的对象
                materials.preload();
                objLoader.setMaterials(materials);
                // 使用 OBJLoader 加载 OBJ 文件
                objLoader.load('models/man.obj', function(object) {
                    mesh = object.children[0];
                    object.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            canvas = MyUtils.textureToCanvas(texture);
                            child.material.map = texture;
                        }
                    });
                    preRender();
                    // 将对象添加到场景中
                    // scene.add(object);
                    targetObject = object;
                    scene.add(targetObject);
                    targetObject.scale.set(0.5,0.5,0.5)
                    // 将模型的中心点设置到canvas坐标系的中心点，保证模型显示是居中的，object就是操作的目标模型
                    let box = new THREE.Box3().setFromObject(object); // 获取模型的包围盒
                    let mdlen = box.max.x - box.min.x; // 模型长度
                    let mdwid = box.max.z - box.min.z; // 模型宽度
                    let mdhei = box.max.y - box.min.y; // 模型高度
                    let x1 = box.min.x + mdlen / 2; // 模型中心点坐标X
                    let y1 = box.min.y + mdhei / 2; // 模型中心点坐标Y
                    let z1 = box.min.z + mdwid / 2; // 模型中心点坐标Z
                    object.position.set(-x1, -y1, -z1); // 将模型进行偏移
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.outputEncoding = THREE.sRGBEncoding;
                });
            });

        }

        function shoot() {
            position.copy( intersection.point );
             // 创建一个圆球的几何体
            const radius = 0.2; // 圆球的半径
            const widthSegments = 12; // 球体宽度上的分段数
            const heightSegments = 12; // 球体高度上的分段数
            const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
            // 创建一个材质
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            // 创建一个圆球的网格模型
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(position.x, position.y, position.z);
            // 将圆球添加到场景中
            decals.push( sphere );
            mesh.attach(sphere)
            sphere.name = `${index++}`
            list.push(JSON.stringify(sphere))
            if(list.length == idList.length) {
            }
        }

        function addFont(m, position) {
            const fontLoader = new FontLoader();
            // Load a font
            fontLoader.load('fonts/helvetiker_regular.typeface.json', function(font) {
                const textGeometry = new TextGeometry('Hello, World!', {
                    font: font,
                    size: 1,
                    height: 0.5
                });
                // Compute the bounding box of the text geometry
                const textBoundingBox = new THREE.Box3().setFromObject(new THREE.Mesh(textGeometry));
                // Compute the size of the box
                const boxSize = textBoundingBox.getSize(new THREE.Vector3()).length();
                // Set the scale factor to fit the text inside the box
                // const scaleFactor = 50 / boxSize;
                // Create the mesh
                const textMesh = new THREE.Mesh(textGeometry, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                // Set the scale of the mesh to fit the text inside the box
                // textMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                textMesh.position.set(position.x, position.y, position.z);
                scene.add(textMesh)
            })
        }

        function removeDecals() {
            decals.forEach( function ( d ) {
                targetObject.children[0].children.splice(targetObject.children[0].children.indexOf(d), 1); 
                // scene.remove( d );
                var s = [];
                s.sli
            });
            decals.length = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function animate() {
            requestAnimationFrame( animate );
            renderer.render( scene, camera );
            stats.update();
        }

        function preRender() {
            for(var i=0; i<preLoadMeshList.length; i++) {
                var model = preLoadMeshList[i];
                // 创建一个圆球的几何体
                const radius = 0.2; // 圆球的半径
                const widthSegments = 12; // 球体宽度上的分段数
                const heightSegments = 12; // 球体高度上的分段数
                const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
                // 创建一个材质
                const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                // 创建一个圆球的网格模型
                var mesh1 = new THREE.Mesh(geometry, material1);
                // Set the transformation matrix
                var matrix = new THREE.Matrix4();
                matrix.makeTranslation(model.object.matrix[12], model.object.matrix[13], model.object.matrix[14]);
                mesh1.matrix = matrix;
                mesh1.position.setFromMatrixPosition(matrix);
                mesh1.rotation.setFromRotationMatrix(matrix);
                mesh1.name = model.object.name;
                mesh.attach(mesh1)
            }
        }
    </script>
</body>

</html>