<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - GLTFloader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        * {
            cursor: crosshair;
        }
        #myBtn {
            position: fixed;
            bottom: 100px;
            right: 50px;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <button id="myBtn">定位</button>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/jsm/"
            }
        }
    </script>

    <script type="module">
        import { TWEEN } from 'https://unpkg.com/three@0.139.0/examples/jsm/libs/tween.module.min.js';
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import Stats from 'three/addons/libs/stats.module.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';
        const MyUtils = {
            textureToCanvas: function(texture) {
                const canvas = document.createElement('canvas');
                canvas.width = texture.image.width;
                canvas.height = texture.image.height;
                const context = canvas.getContext('2d');
                context.drawImage(texture.image, 0, 0);
                return canvas;
            }
        };

        const container = document.getElementById( 'container' );

        let renderer, scene, camera, stats, canvas, texture, targetObject;
        let mesh;
        let raycaster;
        let line;

        const intersection = {
            intersects: false,
            point: new THREE.Vector3(),
            normal: new THREE.Vector3()
        };
        const mouse = new THREE.Vector2();
        const intersects = [];

        const textureLoader = new THREE.TextureLoader();
        const decalDiffuse = textureLoader.load( 'textures/decal-diffuse.png' );
        decalDiffuse.colorSpace = THREE.SRGBColorSpace;
        const decalNormal = textureLoader.load( 'textures/decal-normal.jpg' );

        const decalMaterial = new THREE.MeshPhongMaterial( {
            specular: 0x444444,
            map: decalDiffuse,
            normalMap: decalNormal,
            normalScale: new THREE.Vector2( 1, 1 ),
            shininess: 30,
            transparent: true,
            depthTest: true,
            depthWrite: false,
            polygonOffset: true,
            polygonOffsetFactor: - 4,
            wireframe: false
        } );

        const decals = [];
        let mouseHelper;
        const position = new THREE.Vector3();
        const orientation = new THREE.Euler();
        const size = new THREE.Vector3( 10, 10, 10 );

        const params = {
            minScale: 1,
            maxScale: 100,
            rotate: true,
            clear: function () {
                removeDecals();
            }
        };

        init();
        animate();

        function init() {
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            stats = new Stats();
            container.appendChild( stats.dom );

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.z = 120;

            const controls = new OrbitControls( camera, renderer.domElement );
            controls.minDistance = 50;
            controls.maxDistance = 200;

            scene.add( new THREE.AmbientLight( 0x443333 ) );

            const dirLight1 = new THREE.DirectionalLight( 0xffddcc, 1 );
            dirLight1.position.set( 1, 0.75, 0.5 );
            scene.add( dirLight1 );

            const dirLight2 = new THREE.DirectionalLight( 0xccccff, 1 );
            dirLight2.position.set( - 1, 0.75, - 0.5 );
            scene.add( dirLight2 );

            const geometry = new THREE.BufferGeometry();
            geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] );

            line = new THREE.Line( geometry, new THREE.LineBasicMaterial() );
            scene.add( line );

            loadLeePerrySmith();

            raycaster = new THREE.Raycaster();

            mouseHelper = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial() );
            mouseHelper.visible = false;
            scene.add( mouseHelper );

            window.addEventListener( 'resize', onWindowResize );
            let moved = false;
            controls.addEventListener( 'change', function () {
                moved = true;
            } );

            window.addEventListener( 'pointerdown', function () {
                moved = false;
            } );

            window.addEventListener( 'pointerup', function ( event ) {
                if ( moved === false ) {
                    checkIntersection( event.clientX, event.clientY );
                    if ( intersection.intersects ){
                        // console.dir(intersection);
                        shoot();
                    }

                }

            } );

            window.addEventListener( 'pointermove', onPointerMove );

            function onPointerMove( event ) {

                if ( event.isPrimary ) {

                    checkIntersection( event.clientX, event.clientY );

                }

            }

            document.addEventListener('click', function(event) {
                checkIntersection( event.clientX, event.clientY, true );
            });

            function checkIntersection( x, y, flag ) {

                if ( mesh === undefined ) return;

                mouse.x = ( x / window.innerWidth ) * 2 - 1;
                mouse.y = - ( y / window.innerHeight ) * 2 + 1;

                raycaster.setFromCamera( mouse, camera );
                raycaster.intersectObject( mesh, false, intersects );

                if ( intersects.length > 0 ) {
                    if(flag) {
                        console.dir(intersects[0]);
                    }

                    const p = intersects[ 0 ].point;
                    mouseHelper.position.copy( p );
                    intersection.point.copy( p );

                    const n = intersects[ 0 ].face.normal.clone();
                    n.transformDirection( mesh.matrixWorld );
                    n.multiplyScalar( 10 );
                    n.add( intersects[ 0 ].point );

                    intersection.normal.copy( intersects[ 0 ].face.normal );
                    mouseHelper.lookAt( n );

                    const positions = line.geometry.attributes.position;
                    positions.setXYZ( 0, p.x, p.y, p.z );
                    positions.setXYZ( 1, n.x, n.y, n.z );
                    positions.needsUpdate = true;

                    intersection.intersects = true;

                    intersects.length = 0;

                } else {

                    intersection.intersects = false;

                }

            }

            const gui = new GUI();

            gui.add( params, 'minScale', 1, 30 );
            gui.add( params, 'maxScale', 1, 30 );
            gui.add( params, 'rotate' );
            gui.add( params, 'clear' );
            gui.open();

        }
        var loader = new THREE.TextureLoader();
        texture = loader.load("models/ren_maps/RenTi_MediumColor.jpg");

        function loadLeePerrySmith() {
            // // 创建一个 OBJLoader 和 MTLLoader
            var objLoader = new OBJLoader();
            var mtlLoader = new MTLLoader();
            // 使用 MTLLoader 加载 MTL 文件
            mtlLoader.load('models/1.mtl', function(materials) {
                // 将材质应用于 OBJLoader 加载的对象
                materials.preload();
                objLoader.setMaterials(materials);
                // 使用 OBJLoader 加载 OBJ 文件
                objLoader.load('models/1.obj', function(object) {
                    mesh = object.children[0];
                    object.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            canvas = MyUtils.textureToCanvas(texture);
                            child.material.map = texture;
                        }
                    });
                    // 将对象添加到场景中
                    // scene.add(object);
                    targetObject = object;


                    // 将模型的中心点设置到canvas坐标系的中心点，保证模型显示是居中的，object就是操作的目标模型
                    let box = new THREE.Box3().setFromObject(object); // 获取模型的包围盒
                    let mdlen = box.max.x - box.min.x; // 模型长度
                    let mdwid = box.max.z - box.min.z; // 模型宽度
                    let mdhei = box.max.y - box.min.y; // 模型高度
                    let x1 = box.min.x + mdlen / 2; // 模型中心点坐标X
                    let y1 = box.min.y + mdhei / 2; // 模型中心点坐标Y
                    let z1 = box.min.z + mdwid / 2; // 模型中心点坐标Z
                    object.position.set(-x1, -y1, -z1); // 将模型进行偏移

                    scene.add(targetObject);
                    

                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.outputEncoding = THREE.sRGBEncoding;
                });
            });

        }

        function shoot() {

            position.copy( intersection.point );
            orientation.copy( mouseHelper.rotation );

            if ( params.rotate ) orientation.z = Math.random() * 2 * Math.PI;

            const scale = params.minScale + Math.random() * ( params.maxScale - params.minScale );
            size.set( scale, scale, scale );

            const material = decalMaterial.clone();
            material.color.setHex( Math.random() * 0xffffff );

            const m = new THREE.Mesh( new DecalGeometry( mesh, position, orientation, size ), material );
            // 创建一个圆球的几何体
            const radius = 0.2; // 圆球的半径
            const widthSegments = 12; // 球体宽度上的分段数
            const heightSegments = 12; // 球体高度上的分段数
            const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);

            // 创建一个材质
            const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            // 创建一个圆球的网格模型
            const sphere = new THREE.Mesh(geometry, material1);
            sphere.position.set(position.x, position.y, position.z);

            // 将圆球添加到场景中
            // removeDecals();
            decals.push( sphere );
            // scene.add( sphere );
            targetObject.children[0].children.push(sphere)
            console.dir(targetObject)
            animate();
        }

        function removeDecals() {

            decals.forEach( function ( d ) {
                targetObject.children[0].children.splice(targetObject.children[0].children.indexOf(d), 1); 
                // scene.remove( d );
                var s = [];
                s.sli

            } );

            decals.length = 0;

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

            requestAnimationFrame( animate );

            renderer.render( scene, camera );

            stats.update();

        }
        // // 创建一个 Vector3 对象来存储鼠标点击位置
        // const mouse = new THREE.Vector3();
        // // 创建一个射线投射器
        // var raycaster = new THREE.Raycaster();
        // // 创建一个场景、相机和渲染器
        // var scene = new THREE.Scene();
        // scene.background = new THREE.Color(0xa0a0a0);
        // scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);
        // var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1.5, 23000);
        // var renderer = new THREE.WebGLRenderer();

        // renderer.setPixelRatio(window.devicePixelRatio);
        // renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // renderer.toneMappingExposure = 1.5;
        // renderer.outputEncoding = THREE.sRGBEncoding;
        // const environment = new RoomEnvironment();
        // const pmremGenerator = new THREE.PMREMGenerator(renderer);
        // scene.background = new THREE.Color(0xffffff);
        // scene.environment = pmremGenerator.fromScene(environment).texture;
        // renderer.setSize(window.innerWidth, window.innerHeight);
        // document.body.appendChild(renderer.domElement);

        // // 创建一个光源
        // const hemiLight = new THREE.HemisphereLight(0xffffff, 0x0000ff, 1.5);
        // hemiLight.position.set(0, 50, 0);
        // scene.add(hemiLight);

        // // 创建一个 OBJLoader 和 MTLLoader
        // var objLoader = new OBJLoader();
        // var mtlLoader = new MTLLoader();

        // // 创建 OrbitControls 控制器
        // var controls = new OrbitControls(camera, renderer.domElement);
        // // 添加一个立方体到场景中
        // var geometry = new THREE.BoxGeometry();
        // var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        // var cube = new THREE.Mesh(geometry, material);
        // scene.add(cube);

        // // 使用 MTLLoader 加载 MTL 文件
        // mtlLoader.load('models/1.mtl', function(materials) {
        //     // 将材质应用于 OBJLoader 加载的对象
        //     materials.preload();
        //     objLoader.setMaterials(materials);
        //     // 使用 OBJLoader 加载 OBJ 文件
        //     objLoader.load('models/1.obj', function(object) {
        //         var texture = new THREE.TextureLoader().load("models/ren_maps/RenTi_MediumColor.jpg");
        //         console.dir(texture);
        //         object.traverse(function (child) {
        //             if (child instanceof THREE.Mesh) {
        //                 child.material.map = texture;
        //             }
        //         });
        //         // 将对象添加到场景中
        //         scene.add(object);
        //         // 调整相机位置
        //         camera.position.z = 95;
        //         camera.position.y = 50;

        //         // 创建一个射线投射器
        //         var raycaster = new THREE.Raycaster();
        //         // 创建一个二维向量用于存储鼠标位置
        //         var mouse = new THREE.Vector2();

        //         // 监听鼠标点击事件
        //         document.addEventListener('click', onMouseClick, false);
        //     });
        // });

        // // 渲染场景
        // function animate() {
        //     requestAnimationFrame(animate);
        //     renderer.render(scene, camera);
        //     raycaster.setFromCamera(mouse, camera);
        // }
        // animate();

        // // 在鼠标点击事件处理函数中获取鼠标点击位置，并将其存储在 mouse 对象中
        // function onMouseClick(event) {
        //     const x = (event.clientX / window.innerWidth) * 2 - 1;
        //     const y = -(event.clientY / window.innerHeight) * 2 + 1;
        //     mouse.x = x;
        //     mouse.y = y;
        //     mouse.z = 0.5;
        //     mouse.unproject(camera);

        //     // 更新射线的起点和方向
        //     raycaster.setFromCamera(mouse, camera);
        //     var intersects = raycaster.intersectObjects(scene.children, true);
        //     // 判断是否有交点
        //     if (intersects.length > 0) {
        //         // 输出交点的位置
        //         console.log(intersects[0].point);
        //     }
        // }


        function onButtonClick(e) {
            var prevFov = camera.fov;
            var prevNear = camera.near;
            var prevFar = camera.far;
            // const position = { x: 279, y: 1586.5 };
            const position = { x: 1101, y: 183 };
            const texture = mesh.material.map;
            const width = texture.image.width;
            const height = texture.image.height;
            const u = position.x / width;
            const v = 1 - position.y / height;
            const uv = new THREE.Vector2(u, v);

            const context = canvas.getContext("2d");
            const pixel = context.getImageData(u, v, 1, 1).data;
            const range = 10;
            const x = (pixel[0] / 255) * range;
            const y = (pixel[1] / 255) * range;
            const z = (pixel[2] / 255) * range;
            var targetPosition = new THREE.Vector3(x, y, z);
            targetPosition = new THREE.Vector3(-3.1741442142467955, 22.3706230249142, 2.598552899513386);
            // Jump to the target position
            camera.position.copy(targetPosition);
            targetObject.scale.set(0.8, 0.8, 0.8);


            // camera.position.set(0.15129143339397388, 82.31779111260647,-0.567213551767157);
            const controls = new OrbitControls(camera, canvas);
            controls.target.set(-3.1741442142467955, 22.3706230249142, 2.598552899513386);
            controls.update();

            // Animate to the center
            // var center = new THREE.Vector3(0, 0, 0);
            // new TWEEN.Tween(camera.position)
            //     .to(center, 1000) // animate to the center in 1000 milliseconds
            //     .easing(TWEEN.Easing.Quadratic.InOut) // use quadratic easing
            //     .onUpdate(function() {
            //         // update camera lookAt to always point to the center
            //         camera.lookAt(center);
            //         camera.fov = prevFov;
            //         camera.near = prevNear;
            //         camera.far = prevFar;
            //         // Render the scene
            //         renderer.render(scene, camera);
            //     })
            //     .start();

                const event = new PointerEvent("wheel", {
                    bubbles: true,
                    cancelable: true,
                    clientX: 0,
                    clientY: 0
                    }
                );
            //     console.log('event',event)
            //     document.querySelector('canvas').dispatchEvent(event);
            //     document.querySelector('canvas').dispatchEvent(event);
            //     document.querySelector('canvas').dispatchEvent(event);
                document.querySelector('canvas').dispatchEvent(event);
                // const sphereGeometry = new THREE.SphereGeometry(0.1, 24, 24);
                // const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                // const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                // sphereMesh.position.set(0.15129143339397388, 82.31779111260647,-0.567213551767157);
                // // 将圆球添加到场景中
                // decals.push( sphereMesh );
                // scene.add( sphereMesh );
                // animate();

        }


        document.querySelector('#myBtn').addEventListener('click', onButtonClick)

    </script>
</body>

</html>